// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *Bid) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Bid) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("tenderId")
		s.TenderId.Encode(e)
	}
	{
		e.FieldStart("authorType")
		s.AuthorType.Encode(e)
	}
	{
		e.FieldStart("authorId")
		s.AuthorId.Encode(e)
	}
	{
		e.FieldStart("version")
		s.Version.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		e.Str(s.CreatedAt)
	}
}

var jsonFieldsNameOfBid = [9]string{
	0: "id",
	1: "name",
	2: "description",
	3: "status",
	4: "tenderId",
	5: "authorType",
	6: "authorId",
	7: "version",
	8: "createdAt",
}

// Decode decodes Bid from json.
func (s *Bid) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Bid to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "tenderId":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.TenderId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tenderId\"")
			}
		case "authorType":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.AuthorType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorType\"")
			}
		case "authorId":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.AuthorId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorId\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "createdAt":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Bid")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBid) {
					name = jsonFieldsNameOfBid[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Bid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Bid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BidAuthorId as json.
func (s BidAuthorId) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes BidAuthorId from json.
func (s *BidAuthorId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BidAuthorId to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = BidAuthorId(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BidAuthorId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BidAuthorId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BidAuthorType as json.
func (s BidAuthorType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BidAuthorType from json.
func (s *BidAuthorType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BidAuthorType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BidAuthorType(v) {
	case BidAuthorTypeOrganization:
		*s = BidAuthorTypeOrganization
	case BidAuthorTypeUser:
		*s = BidAuthorTypeUser
	default:
		*s = BidAuthorType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BidAuthorType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BidAuthorType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BidDescription as json.
func (s BidDescription) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes BidDescription from json.
func (s *BidDescription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BidDescription to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = BidDescription(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BidDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BidDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BidId as json.
func (s BidId) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes BidId from json.
func (s *BidId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BidId to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = BidId(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BidId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BidId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BidName as json.
func (s BidName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes BidName from json.
func (s *BidName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BidName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = BidName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BidName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BidName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BidReview) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BidReview) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		e.Str(s.CreatedAt)
	}
}

var jsonFieldsNameOfBidReview = [3]string{
	0: "id",
	1: "description",
	2: "createdAt",
}

// Decode decodes BidReview from json.
func (s *BidReview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BidReview to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BidReview")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBidReview) {
					name = jsonFieldsNameOfBidReview[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BidReview) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BidReview) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BidReviewDescription as json.
func (s BidReviewDescription) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes BidReviewDescription from json.
func (s *BidReviewDescription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BidReviewDescription to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = BidReviewDescription(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BidReviewDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BidReviewDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BidReviewId as json.
func (s BidReviewId) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes BidReviewId from json.
func (s *BidReviewId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BidReviewId to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = BidReviewId(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BidReviewId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BidReviewId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BidStatus as json.
func (s BidStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BidStatus from json.
func (s *BidStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BidStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BidStatus(v) {
	case BidStatusCreated:
		*s = BidStatusCreated
	case BidStatusPublished:
		*s = BidStatusPublished
	case BidStatusCanceled:
		*s = BidStatusCanceled
	default:
		*s = BidStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BidStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BidStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BidVersion as json.
func (s BidVersion) Encode(e *jx.Encoder) {
	unwrapped := int32(s)

	e.Int32(unwrapped)
}

// Decode decodes BidVersion from json.
func (s *BidVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BidVersion to nil")
	}
	var unwrapped int32
	if err := func() error {
		v, err := d.Int32()
		unwrapped = int32(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = BidVersion(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BidVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BidVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateBidForbidden as json.
func (s *CreateBidForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateBidForbidden from json.
func (s *CreateBidForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateBidForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateBidForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateBidForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateBidForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateBidNotFound as json.
func (s *CreateBidNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateBidNotFound from json.
func (s *CreateBidNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateBidNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateBidNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateBidNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateBidNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateBidReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateBidReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("tenderId")
		s.TenderId.Encode(e)
	}
	{
		e.FieldStart("organizationId")
		s.OrganizationId.Encode(e)
	}
	{
		e.FieldStart("creatorUsername")
		s.CreatorUsername.Encode(e)
	}
}

var jsonFieldsNameOfCreateBidReq = [6]string{
	0: "name",
	1: "description",
	2: "status",
	3: "tenderId",
	4: "organizationId",
	5: "creatorUsername",
}

// Decode decodes CreateBidReq from json.
func (s *CreateBidReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateBidReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "tenderId":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.TenderId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tenderId\"")
			}
		case "organizationId":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.OrganizationId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizationId\"")
			}
		case "creatorUsername":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.CreatorUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creatorUsername\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateBidReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateBidReq) {
					name = jsonFieldsNameOfCreateBidReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateBidReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateBidReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateBidUnauthorized as json.
func (s *CreateBidUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateBidUnauthorized from json.
func (s *CreateBidUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateBidUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateBidUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateBidUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateBidUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTenderForbidden as json.
func (s *CreateTenderForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateTenderForbidden from json.
func (s *CreateTenderForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTenderForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateTenderForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTenderForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTenderForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTenderReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTenderReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("serviceType")
		s.ServiceType.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("organizationId")
		s.OrganizationId.Encode(e)
	}
	{
		e.FieldStart("creatorUsername")
		s.CreatorUsername.Encode(e)
	}
}

var jsonFieldsNameOfCreateTenderReq = [6]string{
	0: "name",
	1: "description",
	2: "serviceType",
	3: "status",
	4: "organizationId",
	5: "creatorUsername",
}

// Decode decodes CreateTenderReq from json.
func (s *CreateTenderReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTenderReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "serviceType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ServiceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceType\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "organizationId":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.OrganizationId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizationId\"")
			}
		case "creatorUsername":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.CreatorUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creatorUsername\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTenderReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateTenderReq) {
					name = jsonFieldsNameOfCreateTenderReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTenderReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTenderReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTenderUnauthorized as json.
func (s *CreateTenderUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateTenderUnauthorized from json.
func (s *CreateTenderUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTenderUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateTenderUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTenderUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTenderUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditBidBadRequest as json.
func (s *EditBidBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes EditBidBadRequest from json.
func (s *EditBidBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditBidBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EditBidBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditBidBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditBidBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditBidForbidden as json.
func (s *EditBidForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes EditBidForbidden from json.
func (s *EditBidForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditBidForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EditBidForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditBidForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditBidForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditBidNotFound as json.
func (s *EditBidNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes EditBidNotFound from json.
func (s *EditBidNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditBidNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EditBidNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditBidNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditBidNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditBidReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditBidReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditBidReq = [2]string{
	0: "name",
	1: "description",
}

// Decode decodes EditBidReq from json.
func (s *EditBidReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditBidReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditBidReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditBidReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditBidReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditBidUnauthorized as json.
func (s *EditBidUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes EditBidUnauthorized from json.
func (s *EditBidUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditBidUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EditBidUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditBidUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditBidUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditTenderBadRequest as json.
func (s *EditTenderBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes EditTenderBadRequest from json.
func (s *EditTenderBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditTenderBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EditTenderBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditTenderBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditTenderBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditTenderForbidden as json.
func (s *EditTenderForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes EditTenderForbidden from json.
func (s *EditTenderForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditTenderForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EditTenderForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditTenderForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditTenderForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditTenderNotFound as json.
func (s *EditTenderNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes EditTenderNotFound from json.
func (s *EditTenderNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditTenderNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EditTenderNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditTenderNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditTenderNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditTenderReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditTenderReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ServiceType.Set {
			e.FieldStart("serviceType")
			s.ServiceType.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditTenderReq = [3]string{
	0: "name",
	1: "description",
	2: "serviceType",
}

// Decode decodes EditTenderReq from json.
func (s *EditTenderReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditTenderReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "serviceType":
			if err := func() error {
				s.ServiceType.Reset()
				if err := s.ServiceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditTenderReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditTenderReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditTenderReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditTenderUnauthorized as json.
func (s *EditTenderUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes EditTenderUnauthorized from json.
func (s *EditTenderUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditTenderUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EditTenderUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditTenderUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditTenderUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("reason")
		e.Str(s.Reason)
	}
}

var jsonFieldsNameOfErrorResponse = [1]string{
	0: "reason",
}

// Decode decodes ErrorResponse from json.
func (s *ErrorResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reason":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrorResponse) {
					name = jsonFieldsNameOfErrorResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBidReviewsBadRequest as json.
func (s *GetBidReviewsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBidReviewsBadRequest from json.
func (s *GetBidReviewsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBidReviewsBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBidReviewsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBidReviewsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBidReviewsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBidReviewsForbidden as json.
func (s *GetBidReviewsForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBidReviewsForbidden from json.
func (s *GetBidReviewsForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBidReviewsForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBidReviewsForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBidReviewsForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBidReviewsForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBidReviewsNotFound as json.
func (s *GetBidReviewsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBidReviewsNotFound from json.
func (s *GetBidReviewsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBidReviewsNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBidReviewsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBidReviewsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBidReviewsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBidReviewsOKApplicationJSON as json.
func (s GetBidReviewsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []BidReview(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetBidReviewsOKApplicationJSON from json.
func (s *GetBidReviewsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBidReviewsOKApplicationJSON to nil")
	}
	var unwrapped []BidReview
	if err := func() error {
		unwrapped = make([]BidReview, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem BidReview
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBidReviewsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetBidReviewsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBidReviewsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBidReviewsUnauthorized as json.
func (s *GetBidReviewsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBidReviewsUnauthorized from json.
func (s *GetBidReviewsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBidReviewsUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBidReviewsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBidReviewsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBidReviewsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBidStatusForbidden as json.
func (s *GetBidStatusForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBidStatusForbidden from json.
func (s *GetBidStatusForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBidStatusForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBidStatusForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBidStatusForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBidStatusForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBidStatusNotFound as json.
func (s *GetBidStatusNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBidStatusNotFound from json.
func (s *GetBidStatusNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBidStatusNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBidStatusNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBidStatusNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBidStatusNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBidStatusUnauthorized as json.
func (s *GetBidStatusUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBidStatusUnauthorized from json.
func (s *GetBidStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBidStatusUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBidStatusUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBidStatusUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBidStatusUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBidsForTenderBadRequest as json.
func (s *GetBidsForTenderBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBidsForTenderBadRequest from json.
func (s *GetBidsForTenderBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBidsForTenderBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBidsForTenderBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBidsForTenderBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBidsForTenderBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBidsForTenderForbidden as json.
func (s *GetBidsForTenderForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBidsForTenderForbidden from json.
func (s *GetBidsForTenderForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBidsForTenderForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBidsForTenderForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBidsForTenderForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBidsForTenderForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBidsForTenderNotFound as json.
func (s *GetBidsForTenderNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBidsForTenderNotFound from json.
func (s *GetBidsForTenderNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBidsForTenderNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBidsForTenderNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBidsForTenderNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBidsForTenderNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBidsForTenderOKApplicationJSON as json.
func (s GetBidsForTenderOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Bid(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetBidsForTenderOKApplicationJSON from json.
func (s *GetBidsForTenderOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBidsForTenderOKApplicationJSON to nil")
	}
	var unwrapped []Bid
	if err := func() error {
		unwrapped = make([]Bid, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Bid
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBidsForTenderOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetBidsForTenderOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBidsForTenderOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBidsForTenderUnauthorized as json.
func (s *GetBidsForTenderUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBidsForTenderUnauthorized from json.
func (s *GetBidsForTenderUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBidsForTenderUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBidsForTenderUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBidsForTenderUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBidsForTenderUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTenderStatusForbidden as json.
func (s *GetTenderStatusForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTenderStatusForbidden from json.
func (s *GetTenderStatusForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTenderStatusForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTenderStatusForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTenderStatusForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTenderStatusForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTenderStatusNotFound as json.
func (s *GetTenderStatusNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTenderStatusNotFound from json.
func (s *GetTenderStatusNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTenderStatusNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTenderStatusNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTenderStatusNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTenderStatusNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTenderStatusUnauthorized as json.
func (s *GetTenderStatusUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTenderStatusUnauthorized from json.
func (s *GetTenderStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTenderStatusUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTenderStatusUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTenderStatusUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTenderStatusUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTendersOKApplicationJSON as json.
func (s GetTendersOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Tender(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetTendersOKApplicationJSON from json.
func (s *GetTendersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTendersOKApplicationJSON to nil")
	}
	var unwrapped []Tender
	if err := func() error {
		unwrapped = make([]Tender, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Tender
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTendersOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetTendersOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTendersOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserBidsOKApplicationJSON as json.
func (s GetUserBidsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Bid(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetUserBidsOKApplicationJSON from json.
func (s *GetUserBidsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserBidsOKApplicationJSON to nil")
	}
	var unwrapped []Bid
	if err := func() error {
		unwrapped = make([]Bid, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Bid
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUserBidsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserBidsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserBidsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserTendersOKApplicationJSON as json.
func (s GetUserTendersOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Tender(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetUserTendersOKApplicationJSON from json.
func (s *GetUserTendersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserTendersOKApplicationJSON to nil")
	}
	var unwrapped []Tender
	if err := func() error {
		unwrapped = make([]Tender, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Tender
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUserTendersOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserTendersOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserTendersOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BidDescription as json.
func (o OptBidDescription) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BidDescription from json.
func (o *OptBidDescription) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBidDescription to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBidDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBidDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BidName as json.
func (o OptBidName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BidName from json.
func (o *OptBidName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBidName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBidName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBidName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TenderDescription as json.
func (o OptTenderDescription) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TenderDescription from json.
func (o *OptTenderDescription) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTenderDescription to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTenderDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTenderDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TenderName as json.
func (o OptTenderName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TenderName from json.
func (o *OptTenderName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTenderName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTenderName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTenderName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TenderServiceType as json.
func (o OptTenderServiceType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TenderServiceType from json.
func (o *OptTenderServiceType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTenderServiceType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTenderServiceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTenderServiceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Username as json.
func (o OptUsername) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Username from json.
func (o *OptUsername) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUsername to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUsername) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUsername) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrganizationId as json.
func (s OrganizationId) Encode(e *jx.Encoder) {
	unwrapped := uuid.UUID(s)

	json.EncodeUUID(e, unwrapped)
}

// Decode decodes OrganizationId from json.
func (s *OrganizationId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganizationId to nil")
	}
	var unwrapped uuid.UUID
	if err := func() error {
		v, err := json.DecodeUUID(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrganizationId(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrganizationId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrganizationId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RollbackBidBadRequest as json.
func (s *RollbackBidBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes RollbackBidBadRequest from json.
func (s *RollbackBidBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RollbackBidBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RollbackBidBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RollbackBidBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RollbackBidBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RollbackBidForbidden as json.
func (s *RollbackBidForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes RollbackBidForbidden from json.
func (s *RollbackBidForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RollbackBidForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RollbackBidForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RollbackBidForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RollbackBidForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RollbackBidNotFound as json.
func (s *RollbackBidNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes RollbackBidNotFound from json.
func (s *RollbackBidNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RollbackBidNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RollbackBidNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RollbackBidNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RollbackBidNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RollbackBidUnauthorized as json.
func (s *RollbackBidUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes RollbackBidUnauthorized from json.
func (s *RollbackBidUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RollbackBidUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RollbackBidUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RollbackBidUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RollbackBidUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RollbackTenderBadRequest as json.
func (s *RollbackTenderBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes RollbackTenderBadRequest from json.
func (s *RollbackTenderBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RollbackTenderBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RollbackTenderBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RollbackTenderBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RollbackTenderBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RollbackTenderForbidden as json.
func (s *RollbackTenderForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes RollbackTenderForbidden from json.
func (s *RollbackTenderForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RollbackTenderForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RollbackTenderForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RollbackTenderForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RollbackTenderForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RollbackTenderNotFound as json.
func (s *RollbackTenderNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes RollbackTenderNotFound from json.
func (s *RollbackTenderNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RollbackTenderNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RollbackTenderNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RollbackTenderNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RollbackTenderNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RollbackTenderUnauthorized as json.
func (s *RollbackTenderUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes RollbackTenderUnauthorized from json.
func (s *RollbackTenderUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RollbackTenderUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RollbackTenderUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RollbackTenderUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RollbackTenderUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubmitBidDecisionBadRequest as json.
func (s *SubmitBidDecisionBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes SubmitBidDecisionBadRequest from json.
func (s *SubmitBidDecisionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubmitBidDecisionBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SubmitBidDecisionBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubmitBidDecisionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubmitBidDecisionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubmitBidDecisionForbidden as json.
func (s *SubmitBidDecisionForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes SubmitBidDecisionForbidden from json.
func (s *SubmitBidDecisionForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubmitBidDecisionForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SubmitBidDecisionForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubmitBidDecisionForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubmitBidDecisionForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubmitBidDecisionNotFound as json.
func (s *SubmitBidDecisionNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes SubmitBidDecisionNotFound from json.
func (s *SubmitBidDecisionNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubmitBidDecisionNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SubmitBidDecisionNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubmitBidDecisionNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubmitBidDecisionNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubmitBidDecisionUnauthorized as json.
func (s *SubmitBidDecisionUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes SubmitBidDecisionUnauthorized from json.
func (s *SubmitBidDecisionUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubmitBidDecisionUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SubmitBidDecisionUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubmitBidDecisionUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubmitBidDecisionUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubmitBidFeedbackBadRequest as json.
func (s *SubmitBidFeedbackBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes SubmitBidFeedbackBadRequest from json.
func (s *SubmitBidFeedbackBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubmitBidFeedbackBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SubmitBidFeedbackBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubmitBidFeedbackBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubmitBidFeedbackBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubmitBidFeedbackForbidden as json.
func (s *SubmitBidFeedbackForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes SubmitBidFeedbackForbidden from json.
func (s *SubmitBidFeedbackForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubmitBidFeedbackForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SubmitBidFeedbackForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubmitBidFeedbackForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubmitBidFeedbackForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubmitBidFeedbackNotFound as json.
func (s *SubmitBidFeedbackNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes SubmitBidFeedbackNotFound from json.
func (s *SubmitBidFeedbackNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubmitBidFeedbackNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SubmitBidFeedbackNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubmitBidFeedbackNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubmitBidFeedbackNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubmitBidFeedbackUnauthorized as json.
func (s *SubmitBidFeedbackUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes SubmitBidFeedbackUnauthorized from json.
func (s *SubmitBidFeedbackUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubmitBidFeedbackUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SubmitBidFeedbackUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubmitBidFeedbackUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubmitBidFeedbackUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Tender) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Tender) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("serviceType")
		s.ServiceType.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("organizationId")
		s.OrganizationId.Encode(e)
	}
	{
		e.FieldStart("version")
		s.Version.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
}

var jsonFieldsNameOfTender = [8]string{
	0: "id",
	1: "name",
	2: "description",
	3: "serviceType",
	4: "status",
	5: "organizationId",
	6: "version",
	7: "createdAt",
}

// Decode decodes Tender from json.
func (s *Tender) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Tender to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "serviceType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ServiceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceType\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "organizationId":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.OrganizationId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizationId\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Tender")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTender) {
					name = jsonFieldsNameOfTender[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Tender) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Tender) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TenderDescription as json.
func (s TenderDescription) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes TenderDescription from json.
func (s *TenderDescription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TenderDescription to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TenderDescription(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TenderDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TenderDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TenderId as json.
func (s TenderId) Encode(e *jx.Encoder) {
	unwrapped := uuid.UUID(s)

	json.EncodeUUID(e, unwrapped)
}

// Decode decodes TenderId from json.
func (s *TenderId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TenderId to nil")
	}
	var unwrapped uuid.UUID
	if err := func() error {
		v, err := json.DecodeUUID(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TenderId(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TenderId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TenderId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TenderName as json.
func (s TenderName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes TenderName from json.
func (s *TenderName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TenderName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TenderName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TenderName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TenderName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TenderServiceType as json.
func (s TenderServiceType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TenderServiceType from json.
func (s *TenderServiceType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TenderServiceType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TenderServiceType(v) {
	case TenderServiceTypeConstruction:
		*s = TenderServiceTypeConstruction
	case TenderServiceTypeDelivery:
		*s = TenderServiceTypeDelivery
	case TenderServiceTypeManufacture:
		*s = TenderServiceTypeManufacture
	default:
		*s = TenderServiceType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TenderServiceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TenderServiceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TenderStatus as json.
func (s TenderStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TenderStatus from json.
func (s *TenderStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TenderStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TenderStatus(v) {
	case TenderStatusCreated:
		*s = TenderStatusCreated
	case TenderStatusPublished:
		*s = TenderStatusPublished
	case TenderStatusClosed:
		*s = TenderStatusClosed
	default:
		*s = TenderStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TenderStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TenderStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TenderVersion as json.
func (s TenderVersion) Encode(e *jx.Encoder) {
	unwrapped := int32(s)

	e.Int32(unwrapped)
}

// Decode decodes TenderVersion from json.
func (s *TenderVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TenderVersion to nil")
	}
	var unwrapped int32
	if err := func() error {
		v, err := d.Int32()
		unwrapped = int32(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TenderVersion(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TenderVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TenderVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateBidStatusBadRequest as json.
func (s *UpdateBidStatusBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateBidStatusBadRequest from json.
func (s *UpdateBidStatusBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateBidStatusBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateBidStatusBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateBidStatusBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateBidStatusBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateBidStatusForbidden as json.
func (s *UpdateBidStatusForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateBidStatusForbidden from json.
func (s *UpdateBidStatusForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateBidStatusForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateBidStatusForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateBidStatusForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateBidStatusForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateBidStatusNotFound as json.
func (s *UpdateBidStatusNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateBidStatusNotFound from json.
func (s *UpdateBidStatusNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateBidStatusNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateBidStatusNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateBidStatusNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateBidStatusNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateBidStatusUnauthorized as json.
func (s *UpdateBidStatusUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateBidStatusUnauthorized from json.
func (s *UpdateBidStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateBidStatusUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateBidStatusUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateBidStatusUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateBidStatusUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTenderStatusBadRequest as json.
func (s *UpdateTenderStatusBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateTenderStatusBadRequest from json.
func (s *UpdateTenderStatusBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTenderStatusBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateTenderStatusBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTenderStatusBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTenderStatusBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTenderStatusForbidden as json.
func (s *UpdateTenderStatusForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateTenderStatusForbidden from json.
func (s *UpdateTenderStatusForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTenderStatusForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateTenderStatusForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTenderStatusForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTenderStatusForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTenderStatusNotFound as json.
func (s *UpdateTenderStatusNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateTenderStatusNotFound from json.
func (s *UpdateTenderStatusNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTenderStatusNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateTenderStatusNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTenderStatusNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTenderStatusNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTenderStatusUnauthorized as json.
func (s *UpdateTenderStatusUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateTenderStatusUnauthorized from json.
func (s *UpdateTenderStatusUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTenderStatusUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateTenderStatusUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTenderStatusUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTenderStatusUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Username as json.
func (s Username) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Username from json.
func (s *Username) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Username to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Username(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Username) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Username) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
